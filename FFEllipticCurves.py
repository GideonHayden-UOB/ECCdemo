import numpy as np
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt 
import sympy.ntheory as nt
import warnings


class FiniteFieldEllipticCurve:
    """
    A class to represent an elliptic curve over a finite field.

    ...

    Attributes
    ----------
    a : int
        coefficient of the x term of the curve in Weierstrass form
    b : int
        coefficient of the constant term of the curve in Weierstrass form
    p : int
        prime number that the defines the finite field for which the curve takes values over

    Methods
    -------
    isElem(self, x, y):
        Determine if (x,y) is an element of the curve.

    generatePoints(self):
        Return all points on the curve including infinity.
    
    pointAddition(self, xp, yp, xq, yq):
        Return the addition of two points: (xp,yp) and (xq,yq).

    pointMultiplication(self, x, y, s):
        Return the multiplication of point (x,y) by a scalar s.
     
    generatePointsFromGenerator(self, x, y):
        Return all points of the cyclic subgroup formed by generator <(x,y)> including infinity.    

    pointCompression(self, x, y):
        Return the compression of the point (x,y) -> (x,parity(y)).

    pointDecompression(self, x, ybit):
        Return the decompression of the point (x,parity(y)) -> (x,y).

    groupCardinality(self):
        Return the number of points on the curve including infinity.

    subgroupCardinality(self, x, y):
        Return the number of points in the subgroup generated by <(x,y)>, including infinity.

    isGenerator(self, x, y):
        Determine if (x,y) is a generator of the whole curve.

    cofactor(self, gx, gy):
        Return the cofactor of the subgroup generated by (x,y).
    """
    
    def __init__(self, a:int, b:int, p:int):
        """
        Inits an elliptic curve over a finite field, y^2 = x^3 + ax + b (mod p) with corresponding a,b,p parameters.\n
        p should be prime to form a well defined field. A warning will be thrown if p is (possibly) not prime.
        """
        self.a = a
        self.b = b
        self.p = p
        if not nt.isprime(p):
            warnings.warn("Warning: P may not be a prime, this could lead to errors")
        
    def __str__(self) -> str:
        return "y^2 = x^3 + "+str(self.a)+"x + "+str(self.b)+" (mod "+str(self.p)+")"
    
    def _y2Value(self, x: int) -> int:
        return ((pow(x,3,self.p)+ self.a*x + self.b) %self.p)
    
    def isElem(self, x: int | None, y: int | None) -> bool:
        """
        Return whether a point (x,y) is an element of the curve.\n
        This includes the point at infinity, represented by the pair (None,None)

            Parameters:
                    x : The x coordinate
                    y : The y coordinate
        """
        if (x==None and y==None):
            return True
        if ((isinstance(x, int) and not (isinstance(y, int))) or (isinstance(y, int) and not isinstance(x, int))):
            return False
        return ((x**3  - y**2 + self.a*x + self.b)%self.p ==0)
    
    def generatePoints(self) -> list[tuple[int,int] | tuple[None,None]]:
        """
        Return a list of all points on the curve, including the point at infinity (None,None)
        """        
        points = []
        for x in range(self.p):
            if isQuadraticResidue(self.p, self._y2Value(x)):
                squareRoots = sqrtModPrime(self.p, self._y2Value(x))
                for y in squareRoots:
                    points.append((x,y))
        points.append((None,None))
        return points

    def pointAddition(self, xp:int | None, yp:int | None, xq:int | None, yq:int | None) -> tuple[int,int] | tuple[None,None]:
        """
        Return the addition of 2 points on the curve

            Parameters:
                    xp : The x coordinate of p
                    yp : The y coordinate of p
                    xq : The x coordinate of q
                    yq : The y coordinate of q

            Detail:
                    The point at infinity is the additive identity element of the curve.\n
                    (x,y) + (None,None) = (x,y).\n
                    Adding a point to its negation returns the point at infinity.\n
                    On an elliptic curve over a finite field this will be the point with equal x coordinate but y' = p-y.\n
                    (x,y) + (x,p-y) = (x,y) + -(x,y) = (None,None).\n
                    Adding a point to itself follows the point doubling formula.\n
                    Adding 2 different points follows the point addition formula.\n
                    https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
        """

        assert self.isElem(xp,yp), "p not on the curve"
        assert self.isElem(xq,yq), "q not on the curve"

        if (xp == yp == None):
            return xq,yq
        if (xq == yq == None):
            return xp,yp
        if (xq==xp and (yq+yp)%self.p==0):
            return None,None
        elif (xq==xp and yq==yp):
            return self._pointDouble(xp,yp)
        else:
            lambdaP = (((yq-yp)%self.p) * pow((xq-xp),-1,self.p)) %self.p
            xr = (pow(lambdaP,2,self.p) - xp - xq)%self.p
            yr = (lambdaP*(xp-xr) - yp) %self.p
            return xr,yr

    def _pointDouble(self, x:int, y:int) -> tuple[int,int]:
        lambdaP = (((3*pow(x,2,self.p) + self.a)%self.p) * pow(2*y,-1,self.p)) %self.p 
        xr = (pow(lambdaP,2,self.p) - 2*x)%self.p
        yr = (lambdaP*(x-xr) - y) %self.p
        return xr,yr
    
    def _naivePointMultiplication(self, x:int | None, y:int | None, s:int) -> tuple[int,int] | tuple[None,None]:
        assert s>=0, "can only multiply by non-negative integers"
        if (x==None and y==None):
            return x,y
        assert self.isElem(x,y),str(x)+","+str(y)+" is not a point on the curve"
        if s==0:
            return None,None
        nextx, nexty = x,y
        for i in range(s-1):
            nextx, nexty = self.pointAddition(x,y,nextx,nexty)
        return nextx,nexty
    
    def pointMultiplication(self, x:int | None, y:int | None, s:int) -> tuple[int,int] | tuple[None,None]:
        """
        Return the multiplication of a point on the curve by a non-negative integer scalar.

            Parameters:
                    x : The x coordinate
                    y : The y coordinate
                    s : The scalar
            
            Detail:
                    Multiplying any point 0 returns the point at infinity.\n
                    Multiplying the point at infinity by any scalar returns the point at infinity.\n
                    This implementation uses the double-and-add algorithm.\n
                    https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
        """
        assert isinstance(s,int) and s>=0,"can only multiply by non negative integers"
        assert self.isElem(x,y),"must be a point on the curve"
        if (s==0 or (x==None and y==None)):
            return None,None
        else:
            s = bin(s)
            s = str(s)
            s = s[2:]
            resx,resy = None,None
            tempx,tempy = x,y
            for bit in s[::-1]:
                if (bit == '1'):
                    resx,resy = self.pointAddition(resx,resy,tempx,tempy)
                tempx,tempy = self.pointAddition(tempx,tempy,tempx,tempy)
                            
            return resx,resy

    def generatePointsFromGenerator(self, x:int | None, y:int | None) -> list[tuple[int,int] | tuple[None,None]]:
        """
        Return the set of all points in the subgroup generated by the generator (x,y) including the point at infinity (None,None).

            Parameters:
                    x : The x coordinate of the generator  
                    y : The y coordinate of the generator  
        """
        assert(self.isElem(x,y)),"not a point on the curve"
        if (x==None and y==None):
            return [(None,None)]
        nextx,nexty = self.pointAddition(x,y,x,y)
        points=[(x,y)]
        while (nextx != x or nexty != y):
            points.append((nextx,nexty))
            nextx,nexty= self.pointAddition(x,y,nextx,nexty)

        return points

    def pointCompression(self, x:int, y:int) -> tuple[int,int]:
        """
        Return the compression of a pair of coordinates on the curve.\n

            Parameters:
                    x : The x coordinate  
                    y : The y coordinate 
            
            Details:
                    Since every x coordinate has at most 2 corresponding y coordinates, (x,y) and its negation, (x,y')\n
                    And since y+y' = 0 (mod p), and p is prime (greater than 2) so odd.\n
                    Then one of y or y' is even and the other is odd.\n
                    This can be encoded as the parity of y (0 or 1).\n 
        """
        assert self.isElem(x,y) and isinstance(x,int) and isinstance(y,int),"must be a non-infinity point on the curve"
        return x,(y%2)

    def pointDecompression(self, x:int, ybit:int) -> tuple[int,int]:
        """
        Return the decompression of a pair of coordinates on the curve.\n

            Parameters:
                    x : The x coordinate  
                    ybit : The parity of the y coordinate
            
            Details:
                    Since every x coordinate has at most 2 corresponding y coordinates, (x,y) and its negation, (x,y')\n
                    And since y+y' = 0 (mod p), and p is prime (greater than 2) so odd.\n
                    Then one of y or y' is even and the other is odd.\n
                    This can be encoded as the parity of y (0 or 1).\n 
                    These are all invertible functions so can be decoded easily.\n
        """
        y = sqrtModPrime(self.p,pow(x, 3, self.p) + self.a * x + self.b)[0]
        if bool(ybit) == bool(y & 1):
            return (x, y)
        return x, self.p - y

    def groupCardinality(self) -> int:
        """Return the number of elements in the curve including the point at infinity"""
        return len(self.generatePoints())

    def subgroupCardinality(self, x:int | None, y:int | None) -> int:
        """
        Return the number of elements in the subgroup generated by (x,y) including the point at infinity.

            Parameters:
                    x : The x coordinate of the generator  
                    y : The y coordinate of the generator 
        
        """
        return len(self.generatePointsFromGenerator(x,y))

    def isGenerator(self, x:int | None, y:int | None) -> bool:
        """
        Return whether or not a given point (x,y) is a generator for the whole curve.

            Parameters:
                    x : The x coordinate   
                    y : The y coordinate 
        
        """
        return self.groupCardinality() == self.subgroupCardinality(x,y)

    def cofactor(self, gx:int | None, gy:int | None) -> int:
        """
        Return the cofactor of the curve under a point (x,y).

            Parameters:
                    x : The x coordinate of the subgroup generator
                    y : The y coordinate of the subgroup generator
        
        """        
        order = self.groupCardinality()
        suborder = self.subgroupCardinality(gx,gy)
        cofactor = (order//suborder)
        return cofactor

def isQuadraticResidue(p:int, a:int) -> bool:
    """
    Return whether or not an integer has a square root in the field F_p.\n
    Determine if x exists such that x^2 = a (mod p).

        Parameters:
                p : The prime that the field is in relation to
                a : The integer to check for a root
    """      
    if (a==0 or a==1):
        return True
    else:
        ls = pow(a,(p-1)>>1,p)
        if (ls==1):
            return True
        else:
            return False

def tonelliShanks(p:int, n:int) -> int:
    """
    Return a modular square root of n under the field p.
    i.e. Return x such that x^2 = n (mod p).

        Parameters:
                p : The prime that the field is in relation to
                n : The integer to find the root of, must be a quadratic residue

        Details:
                Implements the tonelli-shanks algorithm.\n
                https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm
    """        
    Q = p-1
    S = 0
    while (Q%2==0):
        Q = Q>>1
        S = S+1
    Q = int(Q)
    z= np.random.randint(2,p-2)
    while (isQuadraticResidue(p,z)):
        z= np.random.randint(2,p-2)

    M = S
    c = pow(z,Q,p)
    t = pow(n,Q,p)
    R = pow(n,(Q+1)>>1,p)

    while(True):
        if (t==0):
            return 0
        elif (t==1):
            return R
        else:
            i=1
            while (pow(t,2**i,p) != 1):
                i = i+1
                if (i==M):
                    raise Exception("n="+str(n)+" is not a quadratic residue mod "+str(p)) 
            b = pow(c,2**(M-i-1),p)
            M = i %p
            c = pow(b,2,p)
            t = (t*(b**2)) %p
            R = (R*b) %p

def sqrtModPrime(p:int ,n:int) -> list[int]:
    """
    Return both modular square roots of n under the field p. 
    i.e. Return (x,x') such that x^2 = n (mod p) and x'^2 = n (mod p).

        Parameters:
                p : The prime that the field is in relation to
                a : The integer to find the root of, must be a quadratic residue

        Details:
                Implements the tonelli-shanks algorithm.\n
                https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm
    """ 
    assert p>=2,"p must be a prime greater than or equal to 2"
    n=n%p
    if (p==2):
        return [n]
    else:
        if (p%4==3):
            r = pow(n,(p+1)>>2,p)
        else:
            r = tonelliShanks(p,n)
        if (r==0):
            return [r]
        else:
            return r,p-r



#implements diffie-hellman key exchange
#parameters are curve, generator point for the curve (consisting of gx,gy) and private keys for alice(a) and bob(b): da,db respectively
def diffieHellmanKeyExchangeExample(curve:FiniteFieldEllipticCurve,gx:int | None, gy:int | None, da:int , db:int):
    """
    Print a simple explanation for diffie-hellman key exchange using the input paramenters.

        Parameters:
                curve : The curve to take points over
                gx : The x coordinate of the generator to use in the key generation
                gy : The y coordinate of the generator to use in the key generation
                da : The private key to use for Alice
                db : The private key to use for Bob
    """ 
    Qa, Qb = curve.pointMultiplication(gx,gy,da), curve.pointMultiplication(gx,gy,db) #generates the public keys of alice and bob
    
    print("Curve: "+str(curve)+"\n"+
          "Generator: "+str((gx,gy))+"\n"+
          "Alice's private key: "+str(da)+", Alice's public key: "+str(Qa)+"\n"+
          "Bob's private key: "+str(db)+", Bob's public key: "+str(Qb))
    
    xk,yk = curve.pointMultiplication(Qa[0],Qa[1],db)
    print("Each person calculates the product of their private key with the other's private key \nThis gives the same value for each person but is not known to other people")
    print("Shared secret is the x value of the calculated point: ",xk)
    print("Alice and Bob now have a shared secret that can be used in a symmetric key algorithm to encrypt and decrypt messages ")

#takes a list of coordinates and returns a tuple of lists of integers
#[(x1,y1),(x2,y2),(x3,y3)] -> ([x1,x2,x3],[y1,y2,y3])
def _pointsUnzip(points: list[tuple[int,int] | tuple[None,None]]) -> tuple[list[int],list[int]]:
    points = list(map(list, zip(*points)))
    return points[0],points[1]

#plots the curve using mathplotlib
def _plotCurve(curve:FiniteFieldEllipticCurve):
    xs,ys = _pointsUnzip(curve.generatePoints())
    fig, (ax1) = plt.subplots(1, 1)
    fig.suptitle('y^2 = x^3 + '+str(curve.b)+ '(mod '+str(curve.p)+')')
    fig.set_size_inches(6, 6)
    ax1.set_xticks(range(0,curve.p))
    ax1.set_yticks(range(0,curve.p))
    plt.grid()
    plt.scatter(xs, ys)
    plt.plot()
    plt.show()





curve = FiniteFieldEllipticCurve(0,3,11)


# curve2 = FiniteFieldEllipticCurve(0,7,17)
# print(curve2.groupCardinality())
# points = curve2.generatePoints()
# print(points)

# print(curve2.isElem(1,12))

# print(curve2.isElem(None,12))
# print(curve2.isElem(3,12))

# print(curve2.isElem(None,None))


#diffieHellmanKeyExchangeExample(curve,4,10,3,6)

#print(curve.generatePointsFromGenerator(4,10))

